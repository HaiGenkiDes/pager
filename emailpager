#!/usr/bin/env python

#stdlib imports
import argparse
import configparser
import os.path
import sys
import smtplib
from xml.dom import minidom
from datetime import datetime

#third party imports
import pandas as pd
import numpy as np
from impactutils.transfer.emailsender import EmailSender
from impactutils.comcat.query import ComCatInfo

#local imports
from losspager.schema import emailschema as es
from losspager.mail.formatter import format_msg,generate_subject_line
from losspager.utils.config import read_mail_config
from losspager.io.pagerdata import PagerData

DEFAULT_PAGER_URL = 'http://earthquake.usgs.gov/data/pager/'

ALERT_DICT = {'green':0,
              'yellow':1,
              'orange':2,
              'red':3}

def get_version(session,pdata):
    eventid = pdata.id
    event = session.query(es.Event).filter(es.Event.eventcode == eventid).first()
    ccinfo = None
    authid = eventid
    if event is None:
        try:
            ccinfo = ComCatInfo(eventid)
            authid,allids = ccinfo.getAssociatedIds()
            allids.insert(0,authid)
            allids.remove(eventid)
            for testid in allids:
                event = session.query(es.Event).filter(es.Event.eventcode == testid).first()
                if event is not None:
                    break
        except:
            pass
    if event is None:
        #we need to create a new event
        event = es.Event(eventcode=authid)

    prow = pdata.toSeries()
    country = prow['Impacted Country ($)']
    #Now create a new version
    pending = pdata.summary_alert_pending
    level = pdata.summary_alert
    if pending == 'pending':
        alert = 'pending/%s' % (ALERT_DICT[pdata.summary_alert])
    else:
        alert = ALERT_DICT[pdata.summary_alert]
    version = es.Version(versioncode = eventid,
                         time = pdata.time,
                         country = country,
                         lat = pdata.latitude,
                         lon = pdata.longitude,
                         depth = pdata.depth,
                         magnitude = pdata.magnitude,
                         number = len(event.versions) + 1,
                         fatlevel = ALERT_DICT[pdata.fatality_alert],
                         ecolevel = ALERT_DICT[pdata.fatality_alert],
                         summarylevel = alert,
                         processtime = pdata.processing_time,
                         maxmmi = pdata.maxmmi)
    event.versions.append(version)
    return (version,event,ccinfo)

def main(args):
    DEBUG = False
    if args.debug:
        DEBUG = True
    
    #get all of the information from the mail config file
    config = read_mail_config()
    
    #first make sure this is a losspager product
    if args.type != 'losspager':
        print('emailpager is only configured to work with losspager products. Exiting.')
        sys.exit(1)

    #Make sure this action is something we're interested in.
    if args.action not in ('EVENT_ADDED','EVENT_UPDATED','PRODUCT_ADDED','PRODUCT_UPDATED'):
        msg = 'No action to take with %s messages.' % args.action
        print(msg)
        sys.exit(1)

    #TODO: Do something with delete messages
    if args.status == 'DELETE':
        msg = 'No action to take with delete messages.' % args.status
        print(msg)
        sys.exit(1)

    jsondir = os.path.join(args.directory,'json')
    if not os.path.isdir(jsondir):
        print('JSON directory "%s" containing PAGER output not found. Exiting.' % args.directory)
        sys.exit(1)

    #Everything is cool...
    pdata = PagerData()
    pdata.loadFromJSON(jsondir)

    #Instantiate a session with our database
    dburl = config['email']['database']['url']
    session = es.get_session(url=dburl,create_db=False)
    
    #Find event in database, or create it if not found.  Return a new version for that event
    version,event,ccinfo = get_version(session,pdata)

    #add/commit the event for now, but we may have to delete it if we crash for any reason
    session.add(event)
    session.commit()

    try:
        #loop over all adddresses, check to see if they should get notified
        all_addresses = session.query(es.Address).all()
        short_addresses = []
        long_addresses = []
        pdf_addresses = []
        for address in all_addresses:
            if address.shouldAlert(version):
                if address.format == 'short':
                    short_addresses.append(address)
                elif address.format == 'long':
                    long_addresses.append(address)
                else:
                    pdf_addresses.append(address)


        #try to find the event url
        if ccinfo is not None:
            event_url = ccinfo.getURL()+'#pager'
        else:
            event_url = DEFAULT_PAGER_URL

        #create the short and long message texts
        short_msg = format_msg(version,pdata,'short',event_url)
        long_msg = format_msg(version,pdata,'long',event_url)

        #create the long and short subjects
        subject = generate_subject_line(version,pdata)

        all_props = {}
        all_props['smtp_servers'] = config['email']['smtp_servers']
        all_props['sender'] = config['email']['sender']
        all_props['subject'] = subject

        #set up mail transfer object for short messages
        if len(short_addresses):
            props = all_props.copy()
            props['recipients'] = [address.email for address in short_addresses]
            props['message'] = short_msg
            if not DEBUG:
                print('Sending short message to %i recipients...' % len(short_addresses))
                sender = EmailSender(properties=props)
                sender.send()
            else:
                print('DEBUG on: would send short message to %i recipients...' % len(short_addresses))
                for addr in short_addresses:
                    print('\t%s' % addr.email)
            version.addresses += short_addresses

        if len(long_addresses):
            props = all_props.copy()
            props['recipients'] = [address.email for address in long_addresses]
            props['message'] = long_msg
            if not DEBUG:
                print('Sending long message to %i recipients...' % len(long_addresses))
                sender = EmailSender(properties=props)
                sender.send()
            else:
                print('DEBUG on: would send long message to %i recipients...' % len(long_addresses))
                for addr in long_addresses:
                    print('\t%s' % addr.email)
            version.addresses += long_addresses

        if len(pdf_addresses):
            onepager_file = os.path.join(args.directory,'onepager.pdf')
            props = all_props.copy()
            props['recipients'] = [address.email for address in pdf_addresses]
            props['message'] = long_msg
            if not DEBUG:
                print('Sending long message, with PDF attachment to %i recipients...' % len(pdf_addresses))
                sender = EmailSender(properties=props,local_files=[onepager_file])
                sender.send()
            else:
                print('DEBUG on: would send long message (w/ attachment) to %i recipients...' % len(pdf_addresses))
                for addr in pdf_addresses:
                    print('\t%s' % addr.email)
            version.addresses += pdf_addresses

    except Exception as e:
        #if we have any errors, we want to back out the event and version we added above.
        #todo - the event might not be new, we can't just delete it, only if its empty
        print('Exception "%s" on input %s Backing out any new events/versions.' % (str(e),args.directory))
        session.delete(version)
        if len(event.versions) == 0:
            session.delete(event)
        session.commit()
    session.commit()
    session.close()
    sys.exit(0)
    
    
if __name__ == '__main__':
    desc='Send emails to PAGER users.'
    argparser = argparse.ArgumentParser(description=desc,
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    argparser.add_argument("--debug", action='store_true',default=False,
                           help='Turn off emailing, print out who *would* be notified.')
    argparser.add_argument("--directory",
                           help="Directory where PAGER data can be found",metavar='DIRECTORY')
    argparser.add_argument("--type", 
                           help="Product type",metavar='TYPE')
    argparser.add_argument("--code", 
                           help="Product code",metavar='CODE')
    argparser.add_argument("--source", 
                           help="Product source",metavar='SOURCE')
    
    argparser.add_argument("--status", 
                           help="Product status",metavar='STATUS')
    argparser.add_argument("--action", 
                           help="Product action",metavar='ACTION')
    argparser.add_argument("--preferred-latitude", type=float,
                           help="Event latitude",metavar='LAT',dest='lat')
    argparser.add_argument("--preferred-longitude", type=float,
                           help="Event longitude",metavar='LON',dest='lon')
    argparser.add_argument("--preferred-depth", type=float,
                           help="Event depth",metavar='DEPTH',dest='depth')
    argparser.add_argument("--preferred-magnitude", type=float,
                           help="Event magnitude",metavar='MAG',dest='magnitude')
    argparser.add_argument("--preferred-eventtime", 
                           help="Event time",metavar='TIME',dest='time')
    pargs, unknown = argparser.parse_known_args()
    main(pargs)
